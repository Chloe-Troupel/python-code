# -*- coding: utf-8 -*-
"""Berard_Troupel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1f7yVwbJvC9If-vmj1QpKTpiQoGP6jiC0
"""

import numpy
import shutil
import math
import csv
import os
import pandas as pd
from PIL import Image as img
from sklearn.cluster import KMeans, MiniBatchKMeans
from IPython.display import Image, display
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import LabelEncoder
from sklearn.metrics import accuracy_score

def FindColor(img):
    """
    parameter: img (a picture)
    return ret: a string with the main color of img
    """
    #First of all, we use the MiniBatchKMeans to find the RGB hexadecimal values of the main color.
    n = 4
    numarray = numpy.array(img.getdata(), numpy.uint8)
    clusters = MiniBatchKMeans(n_clusters = n)
    clusters.fit(numarray)

    npbins = numpy.arange(0, n+1)
    histogram = numpy.histogram(clusters.labels_, bins=npbins)
    labels = numpy.unique(clusters.labels_)
    maxi = max(histogram[0])
    k = numpy.argmax(histogram[0])
    #This part is able to recognize some colors from their RGB hexadecimal values.
    L = [
         math.ceil(clusters.cluster_centers_[k][0]), 
         math.ceil(clusters.cluster_centers_[k][1]), 
         math.ceil(clusters.cluster_centers_[k][2])
         ]#L = [R, G, B] values
    ret = 'error'
    if 0.5*L[0] > L[1] and 0.5*L[0] > L[2]:
        ret = 'rouge'
    elif 0.5*L[1] > L[0] and 0.5*L[1] > L[2]:
        ret = 'vert'
    elif 0.5*L[2] > L[1] and 0.5*L[2] > L[0]:
        ret = 'bleu'
    elif L[0] > 150 and L[1] > 150 and L[2] < 100:
        ret = 'jaune'
    elif 0.4*L[0] < L[1] < 0.8*L[0] and L[2] < 50:
        ret = 'marron'
    elif ((0.75*L[0] < L[2] < 1.25*L[0] and L[0] > 150) \
          or (L[2] < 0.7*L[0])) and L[1] < L[2] < 160:
        ret = 'rose'
    elif ((0.75*L[2] < L[0] < 1.25*L[2] and L[0] < 150) \
          or (L[0] < 0.7*L[2])) and L[1] < L[0] < 160:
        ret = 'violet'
    elif L[0] > 200 and 100 < L[0] < 150 and L[2] < 50:
        ret = 'orange'
    elif L[0] > 200 and L[1] > 200 and L[2] > 200:
        ret = 'blanc'
    elif 70 < L[0] < 180 and 70 < L[1] < 180 and 70 < L[2] < 180:
        ret = 'gris'
    elif L[0] < 50 and L[1] < 50 and L[2] < 50:
        ret = 'noir'
    elif L[0] >= L[1] and L[0] >= L[2]:
        ret = 'rouge'
    elif L[1] >= L[0] and L[1] >= L[2]:
        ret = 'vert'
    elif L[2] >= L[1] and L[2] >= L[0]:
        ret = 'bleu'
    return ret

#Retrieving the training data and the image bank
if os.path.exists("/content/images"):
    pass
else:
    !git clone -q -s https://gitlab.com/LucasBerard/imagesdm.git images
    !git clone -q -s https://gitlab.com/LucasBerard/images_choice.git images_choice
    !git clone -q -s https://gitlab.com/LucasBerard/csv.git CSV
    shutil.rmtree("/content/images/.git")
    shutil.rmtree("/content/images_choice/.git")
    shutil.rmtree("/content/CSV/.git")
    

#Retrieving tags of the csv file
tags=[]
with open('CSV/landscape.csv', newline='') as f:
    next(f, None)           #to skip the first line
    reader = csv.reader(f)
    for row in reader:
        tags.append(row[1].lower())

#Sorting files in the directory images_choice
Limage=[]
for image in os.listdir('/content/images_choice'):
      Limage.append(image)
Limage.sort()

#Retrieving data from image bank
images_choice=[]
i=0
for image in range(len(Limage)):
    chemin = '/content/images_choice/' + Limage[image]
    imgfile = img.open(chemin)
    taille = str(imgfile.size)
    maincolor = FindColor(imgfile)
    images_choice.append([maincolor,tags[i],taille])
    i+=1

#Retrieving data from training data
result=[]
data=[]
print("\nNous allons vous montrer de nombreuses images. \
  \nPouvez-vous indiquer un tag et si l'image vous plait particulièrement ?")
#For every images in the directory, we will get some information
for image in os.listdir('/content/images'):
    chemin = '/content/images/' + image
    imgfile = img.open(chemin)
    taille = str(imgfile.size) #The size
    display(Image(chemin, width=400, height=400))
    maincolor = FindColor(imgfile) #The main color
    print(maincolor)
    tag = input("Pouvez-vous ajouter un tag pour cette image svp : ")
    tag = tag.lower() #A tag
    pref = input("Cette image vous plaît-elle particulièrement ? (o/n) : ") #if the user likes it
    data.append([maincolor,tag,taille]) #We add it to a futur dataframe
     
    if pref == "o": #We add it to another futur dataframe as favorite or not
        result.append('favorite')
    elif pref == "n":
        result.append('not favorite')

#creating dataframes
dataframe = pd.DataFrame(data, columns=['colors', 'tags', 'image size'])
resultframe = pd.DataFrame(result, columns=['favorite'])
imagesframe = pd.DataFrame(images_choice, columns=['colors', 'tags', 'image size'])

#generating numerical labels 
le1 = LabelEncoder()
dataframe['colors'] = le1.fit_transform(dataframe['colors'])

le2 = LabelEncoder()
dataframe['tags'] = le2.fit_transform(dataframe['tags'])

le3 = LabelEncoder()
dataframe['image size'] = le3.fit_transform(dataframe['image size'])

le1b = LabelEncoder()
imagesframe['colors'] = le1b.fit_transform(imagesframe['colors'])

le2b = LabelEncoder()
imagesframe['tags'] = le2b.fit_transform(imagesframe['tags'])

le3b = LabelEncoder()
imagesframe['image size'] = le3b.fit_transform(imagesframe['image size'])

le4 = LabelEncoder()
resultframe['favorite'] = le4.fit_transform(resultframe['favorite'])

#Use of random forest classifier
rfc = RandomForestClassifier(n_estimators=10, max_depth=2,
                             random_state=0)
rfc = rfc.fit(dataframe, resultframe.values.ravel()) #build a forest of trees
#from the training set (x,y

#prediction and display of favorite images
predic_true=[]
predictions=[]
for line in range(len(imagesframe)):
  prediction = rfc.predict([
    [le1b.transform(le1b.inverse_transform([imagesframe['colors'][line]]))[0],
     le2b.transform(le2b.inverse_transform([imagesframe['tags'][line]]))[0],
     le3b.transform(le3b.inverse_transform([imagesframe['image size'][line]]))[0]
     ]])
  predictions.append(prediction)
  if prediction[0] == 0: #the picture is in the class favorite
    print("\nVoici une image que vous pourriez aimer")
    i=0
    for image in range(len(Limage)):
      if i == line:
        chemin = '/content/images_choice/' + Limage[image]
        imgfile = img.open(chemin)
        display(Image(chemin, width=400, height=400))
        predic_true.append([int(input("Est-ce qu'elle vous plaît vraiment ? (0(oui)/1(non)) : "))])
      i+=1
  else:                 #the picture is in class not favorite
    i=0
    for image in range(len(Limage)):
      if i == line:
        chemin = '/content/images_choice/' + Limage[image]
        imgfile = img.open(chemin)
        display(Image(chemin, width=400, height=400))
        predic_true.append([int(input("Cette image est classée comme non favorite.\
        \nEst-ce qu'elle vous plaît tout de même? (0(oui)/1(non)) : "))])
      i+=1

#importances of features and accuracy
print("\nImportance des différentes caractéristiques (couleur, tag, taille image) :", 
      rfc.feature_importances_)
print("\nPrécision du model :",accuracy_score(predic_true, predictions))